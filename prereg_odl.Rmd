---
title: "A pre-registration analysis of the relationship between intrinsic goal orientation and help-seeing and the effect of reporting as female or as non-female on intrinsic goal orientation."
group: "14"
author: "2608549s, 9404607s, 2704012l, 2723274s, 2719030s, 22716710s"
output:
  word_document: default
  html_document: default
    df_print: paged
  pdf_document: default
---

# Questions

**#	1. Present your main research questions and hypotheses being tested in this study along with a concise rationale for each hypothesis.**

Main research questions : Do female students report more intrinsic goal orientation than students who do not report as female? 
                          Is intrinsic goal orientation related to self-reported help-seeking in female students?

  
Correlation hypothesis  : In female students, intrinsic goal orientation will have a positive correlation to self-reported help-seeking. 

T-test hypothesis       : Female students will report more intrinsic goal orientation than students who do not report as female.  

**# 2. Describe the key variables specifying how they will be measured, how many levels they have, and how participants will be assigned (if relevant).**

Demographic variables : Female, Non-female
Column identifier     : user_sex
Grouping              : Female     = (user_sex == "female")
                      : Non-female = (user_sex == "male" or "nonbinary" or "na")
                      
MSLQ variables
Motivation scale        : (Subcategory) Value
                        : (Subscale)    Intrinsic goal orientation (4 questions)
Learning strategy scale : (Subcategory) Resource management
                        : (Subscale)    Help seeking (4 questions)

**# 3. Describe your precise rule(s) for including and/or excluding observations and/or participants.**

Data from participants with missing fields for user_sex were excluded as we cannot assume the participants gender. 

Data from participants who entered "na" in the user_sex field were grouped with "male" and "nonbinary" for the 'non.female' variable, as we cannot assume whether the participant intended the meaning as "nonbinary" or that they would rather not disclose. 

**# 4. Describe exactly which inferential analyses you will conduct to examine the main hypotheses, including details of any assumption tests.**

Correlation assumptions : Paired Spearman's Rank Correlation
                        : Data are normally distributed
                        : Data are ordinal/continuous (scale/mean)
                        : Data are paired
                        
T-test assumptions      : Welch T-test
                        : Data are normally distributed
                        : Data are ordinal/continuous (scale/mean)
                        : Data are independent

**# 5. Discuss how many observations will be required to determine your smallest effect size of interest, based on your alpha and power, and give rationale for the desired effect size.**

Alpha : 0.05 (our significance level)
      : The odds of saying there is a relationship difference or gain when in fact there is not one
Power : 0.80 (statistical, 1-beta) 
      : The odds of saying there is a relationship difference or gain when in fact there is one
      
Desired effect size : 

# References

# Analysis code: intro

This template assumes that you will be running one t-test and a correlation, if you have decided to do something more complex then this template may not fit your needs. Some of the code has been completed for you to clean up the raw questionnaire output from Experimentum. Remember to knit the file after each step, it will make it easy to spot if you have made an error.

Finally, remember that the pilot data is a small sample compared to the larger dataset that you will work with for the full quantitative report. There may be missing data or types of participants in the full data set that aren't present in this sample.

**You can delete the above instructions before you knit and submit your final pre-reg**

# Analysis code

#### 1. Load in packages and data

```{r library_data}

# install package - pwr

library(pwr)
library(broom)
library(dplyr)
library(stats)
library(ggplot2)
library(tidyverse)

# you will need to add extra packages in here to do the rest of your analyses

demo <- read_csv("demographics_2021_pilot.csv")
mslq <- read_csv("MSLQ_2021_pilot.csv")

```


#### 2. Clean up the data

Run the below code - don't change anything. This code will clean up the Experiment data a little bit to help you on your way. 

```{r data_clean}

demo_final <- demo %>% 
  group_by(user_id, q_id) %>% 
  filter(session_id == min(session_id), endtime == min(endtime)) %>% 
  filter(row_number() == 1) %>% 
  ungroup() %>% 
  filter(user_status %in% c("guest", "registered")) %>%
  select(user_id, user_sex, user_age, q_name, dv) %>%
  pivot_wider(names_from = q_name, values_from = dv)

mslq_final <- mslq %>% 
  group_by(user_id, q_id) %>% 
  filter(session_id == min(session_id), endtime == min(endtime)) %>% 
  filter(row_number() == 1) %>% 
  ungroup() %>% 
  filter(user_status %in% c("guest", "registered")) %>%
  select(user_id, user_sex, user_age, q_name, dv) %>%
  arrange(q_name) %>%
  pivot_wider(names_from = q_name, values_from = dv)

```


#### 3. Join together the data files by their common columns

```{r join_data}

# merge data frames
joined_data <- as_tibble(merge(demo_final, 
                               mslq_final))

```


#### 4. Use select to retain only the variables you need for your chosen research design (including the user ID).

```{r select_cols}

# select the gender column, and MSLQ variables
selected_data <- select(joined_data,
                        user_id, user_sex,
                        intrinsic_1:intrinsic_4,
                        help_1:help_4)

```


#### 5. If necessary, use a filter to retain only the observations you need. For example, you might need to delete participants above a certain age, or only use mature students etc.

```{r filter_option}

# convert to data.frame and drop NaNs
data <- data.frame(drop_na(selected_data))

```


#### 6. Use `summary()` or `str()` to check what type of variable each variable is. Recode any necessary variables as factors and, if you would like to, change numeric codes (e.g., 1 for native speaker) into words to make it easier to read the output. 

```{r check_type}

# data info
summary_stats <- summary(data)

# MSLQ variables
subscales <- c("intrinsic", 
               "help")
help      <- c(names(data)[str_detect(names(data), 
                                      "help")])
intrinsic <- c(names(data)[str_detect(names(data), 
                                      "intrinsic")])

# group non-female observations
data <- mutate(data,
               user_sex = case_when(user_sex %in% c("nonbinary",
                                                    "na") ~ "non-female",
                                  user_sex == "male"      ~ "non-female",
                                  user_sex == "female"    ~ "female"))

# group by count
data_count <- (data %>% 
                 count(user_sex))

# restructure
data_distribution <- pivot_longer(data,
                                  cols=c(intrinsic, help),
                                  names_to="item",
                                  values_to="response")

# gender variables
gender   <- c(unique(data_distribution$user_sex))
n_gender <- c(sum(data_count$n[data_count$user_sex == "female"]),
              sum(data_count$n[data_count$user_sex != "female"]))

# plotting variables
black    = "#000000"
grey     = "#999999"
yellow   = "#E69F00"

# plot gender counts
# jpeg(file="plots/count.jpeg")
barplot(data_count$n, 
        names.arg=data_count$user_sex,
        ylab="n", xlab="user_sex",
        col=c(grey, yellow, yellow, yellow))
legend("topright", 
       c(sprintf("%s = %i", gender[1], n_gender[1]), 
         sprintf("%s = %i", gender[2], n_gender[2])), 
       fill = c(grey, yellow))
# dev.off()

# plot data distribution
# jpeg(file="plots/distribution.jpeg")
ggplot(data=data_distribution, 
       mapping=aes(x=response, color=user_sex, fill=user_sex)) + 
  geom_histogram(binwidth=.5, position="dodge") + 
  facet_wrap(facet=vars(item)) +
  scale_color_manual(values=c(grey, yellow)) +
  scale_fill_manual(values=c(grey, yellow)) + 
  theme(legend.position="top")
# dev.off()

```


#### 7. Calculate the mean score for each participant for each sub-scale. There are a few ways you can do this but helpfully the Experimentum documentation provides example code to make this easier - shown below. For now, you just need to adapt the below code for the variables you need. You may also want to change the `na.rm = TRUE` for the calculation of means depending on whether you want to only include participants who completed all questions.

At the top of the code chunk below, change `eval = FALSE` to `eval = TRUE` once you have amended your code. The reason it is currently set to FALSE is to allow the file to knit. `eval = FALSE` says ignore the code chunk. `eval = TRUE` says run the code chunk

```{r desc, eval = TRUE}

dat_means <- data %>% # change data to the name of the data object you want to work from
  gather(var, val, intrinsic_1:intrinsic_4) %>% # change question_1:question_5 to select the questions for your 1st sub-scale 
  group_by_at(vars(-val, -var)) %>% # group by everything except the val and var columns, don't change this 
  summarise(intrinsic_mean = mean(val, na.rm = TRUE)) %>% # change anxiety_mean to the name of your 1st sub-scale
  ungroup() %>% # always ungroup! 
  gather(var, val, help_1:help_4) %>% # change question_1:question_5 to select the questions for your 2nd scale
  group_by_at(vars(-val, -var)) %>% 
  summarise(help_mean = mean(val, na.rm = TRUE)) %>% # does not return sums with missing items 
  ungroup()

```


#### 8. You now have the dataset in the format that you need for analysis. You could have actually combined all of the above steps together in one mega pipe-line of code if you felt confident but when starting it helps to break it down. Next, you should visualise the data for each analysis.

t-test visualisation (violin plot with boxplot?)

```{r ttest_vis}

dat_means_grouped <-  pivot_longer(dat_means,
                      cols=c(intrinsic_mean, help_mean),
                      names_to="subscale",
                      values_to="mean")

# jpeg(file="plots/boxplots.jpeg")
ggplot(data=dat_means_grouped,
       mapping=aes(x=subscale, y=mean, color=user_sex, fill=user_sex)) + 
  geom_violin(trim=FALSE, alpha=0.5) +
  geom_boxplot(width=0.07, position=position_dodge(width=0.9)) +
  scale_color_manual(values=c(black, black)) +
  scale_fill_manual(values=c(grey, yellow)) + 
  theme(legend.position="top")
# dev.off()

# remove outliers
female_outliers      <- boxplot(subset(subset(dat_means_grouped, user_sex == "female"), subscale == "help_mean")$mean, plot=FALSE)$out
non.female_outliers  <- boxplot(subset(subset(dat_means_grouped, user_sex != "female"), subscale == "intrinsic_mean")$mean, plot=FALSE)$out

dat_means_grouped <- dat_means_grouped[-which(subset(subset(dat_means_grouped, user_sex == "female"), subscale == "help_mean")$mean %in% female_outliers),]
dat_means_grouped <- dat_means_grouped[-which(subset(subset(dat_means_grouped, user_sex != "female"), subscale == "intrinsic_mean")$mean %in% non.female_outliers),]

dat_means <- dat_means[-which(
  subset(dat_means, user_sex == "female")$help_mean
  %in% 
    boxplot(subset(dat_means, user_sex == "female")$help_mean, plot=FALSE)$out),]

dat_means <- dat_means[-which(
  subset(dat_means, user_sex != "female")$intrinsic_mean
  %in% 
    boxplot(subset(dat_means, user_sex != "female")$intrinsic_mean, plot=FALSE)$out),]

```

correlation visualisation (scatterplot?)

```{r corr_vis}

female_data     <- subset(dat_means, 
                          user_sex == "female")
non.female_data <- subset(dat_means,
                          user_sex == "non-female")

# jpeg(file="plots/correlation.jpeg")
ggplot(data=female_data, 
       aes(x=intrinsic_mean, 
           y=help_mean)) + 
  geom_point()
# dev.off()

```


#### 9. Now you should check that the data meets the assumptions of the tests you want to conduct.

t-test assumptions (normality, etc.)

```{r ttest_assump}

# shapiro-wilk test for normality
# separated for gender and subscale

gender_      <- vector(mode="list")
subscale_    <- vector(mode="list")
p.value_     <- vector(mode="list")
d.statistic_ <- vector(mode="list")

count = 1

for (i in seq_along(gender))
  {
  for (j in seq_along(subscales))
    {
    
    vec <- 
      subset(dat_means_grouped,
                user_sex == gender[i]) %>%
      filter(., 
             grepl(subscales[j], 
                   subscale))
    
    vec_sw <- shapiro.test(vec$mean)
    
    gender_[count]      <- gender[i]
    subscale_[count]    <- subscales[j]
    d.statistic_[count] <- vec_sw$statistic
    p.value_[count]     <- vec_sw$p.value
    
    count = count + 1
    
    }
  }

sw_results     <- tibble(gender_, 
                         subscale_,
                         d.statistic_, 
                         p.value_)

gender_results <- tibble("gender"            = gender,
                         "num. observations" = n_gender)

# jpeg(file="plots/mean_distribution.jpeg")
ggplot(data=dat_means_grouped,
       mapping=aes(x=mean, color=user_sex, fill=user_sex)) +
  geom_histogram(binwidth=1, position="dodge") +
  facet_wrap(facet=vars(subscale)) +
  scale_color_manual(values=c(grey, yellow)) +
  scale_fill_manual(values=c(grey, yellow)) +
  theme(legend.position="top")
# dev.off()

print(sw_results)
 
```

correlation assumptions (normality, linearity, homeoscedasticity, etc.)

```{r cor_assump}

# red lines should be flat for both plots
# need to check for statistical equations for p-value
# check to rectify the data

# test for linearity
lingress_model <- lm(data=female_data,
                     help_mean ~ intrinsic_mean)

# jpeg(file="plots/data_linearity.jpeg")
plot(lingress_model, 1)
# dev.off()

# test for homoscedasticity
# jpeg(file="plots/data_homoscedasticity.jpeg")
plot(lingress_model, 3)
# dev.off()

```

``` {r m.clean_vars, eval=FALSE} 

# remove raw data objects
rm(demo, 
   mslq,
   demo_final,
   mslq_final,
   joined_data,
   selected_data)

rm(vec,
   vec_sw,
   gender_,
   p.value_,
   subscale_,
   d.statistic_,
   data_count,
   data_distribution,
   lingress_model)

rm(i, j,
   count,
   gender,
   n_gender,
   help, 
   intrinsic)

```

#### 10. Finally, you can conduct your statistical analyses. Don't forget to calculate effect sizes for the t-tests!

t-test analysis (between or within)

```{r ttest_analysis}

# cohen's d

mean_diff = mean(female_data$intrinsic_mean) - mean(non.female_data$intrinsic_mean)

sum_var   = var(female_data$intrinsic_mean) + var(non.female_data$intrinsic_mean)

d <- mean_diff/sqrt((sum_var)/2)

# power analysis
pwr <- power.t.test(n           = NULL,
                    delta       = mean_diff,
                    # sd          = 1,
                    sig.level   = 0.05,
                    power       = 0.80,
                    type        = "two.sample",
                    alternative = "one.sided")

effect_sizes = c(seq(0.1,1.5,0.1))
ptab        <- cbind(NULL, NULL) 

for (i in effect_sizes) {
  pwr_ <- pwr.t.test(d           = i,
                     sig.level   = 0.05,
                     power       = 0.8,
                     type        = "one.sample",
                     alternative = "greater")
  ptab <- rbind(ptab, cbind(pwr_$d, pwr_$n))
}

plot(ptab[,1],
     ptab[,2],
     type="b",
     xlab="effect size",
     ylab="sample size")

# welch t-test: unequal variance

t <- t.test(female_data$intrinsic_mean, non.female_data$intrinsic_mean)

t.test_results <- tibble("cohen's d" = d,
                         "welch's t" = t$statistic,
                         "p-value"   = t$p.value)

print(t.test_results)

```

correlation analysis (pearson or spearman)

```{r cor_analysis}

# spearman: ordinal data

s <- cor.test(female_data$intrinsic_mean, female_data$help_mean, method="spearman",
              conf.level=0.95, 
              alternative="two.sided")

spearman_results <- tibble("rho" = s$estimate,
                           "p-value" = s$p.value)

effect_sizes = c(seq(0.1,1.5,0.02))
ptab_s <- cbind(NULL, NULL) 

for (i in effect_sizes) {
  pwr_ <- pwr.t.test(d           = i,
                     sig.level   = 0.05,
                     power       = 0.8,
                     type        = "one.sample",
                     alternative = "two.sided")
  ptab_s <- rbind(ptab_s, cbind(pwr_$d, pwr_$n))
}

plot(ptab[,1],
     ptab[,2],
     type="b",
     xlab="effect size",
     ylab="sample size")

```



